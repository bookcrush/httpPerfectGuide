# HTTP
`HTTP(Hypertext Transfer Protocol)`은 `WWW(World Wide Web)`에서 통신하는데 사용하는 프로토콜 프로그램입니다.
즉, 전 세계의 웹 브라우저, 서버, 웹 애플리케이션은 **모두** `HTTP`를 통해서 대화를 하게 되어있습니다. <br/>
현재 셀 수 없이 많은 이미지, HTML 페이지, 텍스트 파일, 동영상 등 쉴틈없이 인터넷에서 움직이고 있습니다.
이런 상황에서 HTTP는 전 세계에 이 정보들을 **빠르고, 간편하고, 정확하게** 각 PC의 브라우저로 옮겨줄 수 있습니다.<br/>
정말 신기하기도 하고 의아한 점은 이러한 많은 정보들을 전송 중 **꼬이거나 손상되지 않는다**는 점입니다.
그렇기 떄문에 개발자 입장에서는 HTTP를 사용함으로써 전송에러를 걱정하지 않고 개발을 할 수 있다는 것입니다.! 👍👍<br/>
그러면 이렇게 좋은 HTTP는 어떻게 웹 트래픽을 전송하는지 알아보도록 하겠습니다.<br/>
<br/>

# 웹 클라이언트와 서버
웹 컨텐츠들이 존재하는 `웹 서버`는 HTTP로 의사소통 하기 때문에 `HTTP 서버`라고 불립니다.
HTTP `서버`는 데이터들을 저장하고 있다가 HTTP `클라이언트` 측에서 요청하면 그에 맞는 데이터를 보내게 됩니다.
> HTTP 클라이언트(웹 브라우저) : "야 네이버! default file(ex. index.html) 페이지 내놔!!!" 
요청 대상 - www.naver.com<br/>
HTTP 서버(Naver 서버) : "드..드리겠습니다.. 여기 HTTP 포맷, 300자로 이루어진 문서입니다.." 
요청 결과 - www.naver.com/index.html

위 예시가 WWW의 기본 구성 요소입니다.
현재 Chrome, Explorer 등 많은 `브라우저들`을 사용중일텐데 이 것이 바로 `HTTP 클라이언트`입니다.<br/>
<br/>

# 리소스
웹 서버는 웹 리소스를 관리하고 제공하는 역할을 합니다. 여기서 `웹 리소스`는 웹 컨텐츠의 원천입니다. 즉 원조의 역할을 합니다. 😀
웹 리소스는 가장 단순하게는 웹 서버 파일 시스템의 `정적 파일`입니다.
> 정적 파일 : 텍스트, HTML, 워드, JPEG 이미지 등의 파일을 포함합니다.

하지만 웹 리소스가 꼭 정적 파일일 필요는 없습니다. 때로는 요청에 따라 컨텐츠를 생산하는 프로그램이 될 수도 있는데 사용자가 누구인지에 따라, 어떤 정보를 요청했으며, 언제 요청했는지 까지 파악하여 다른 컨텐츠를 생성하기도 합니다.<br/>
즉 `리소스`는 정적, 동적, 게이트웨이 등 **모든 종류의 컨텐츠**를 포함하는 것입니다. <br/>
<br/>

## 미디어 타입
인터넷은 엄청 많은 데이터를 가지고 있어 웹에서 전송된 객체 각각에 `MIME` 타입이라는 데이터 포멧 라벨을 붙이게 됩니다. 여기서 MIME이란 무엇인지 알아볼까요?
MIME(Multipurpose Internet Main Extensions)은 다목적 인터넷 메일 확장 이라는 뜻을 가지고 있으며, 다른 전자메일 사이에서 오가는 문제를 해결하기 위해 설계되었습니다.
이 방식을 `HTTP`에서도 채택하여 `멀티미디어 콘텐츠`를 기술하고 `라벨`을 붙이기 위해 채택하게 되었습니다.<br/>
**웹 브라우저**는 **서버**에서 객체를 받을 때 MIME 타입을 붙여서 받게 됩니다. 표현 방식은 `주 타입 / 부 타입`으로 나누어져 있습니다.
설명만 들으면 잘 이해가 안될 수도 있으니 구체적인 예를 보겠습니다‼<br/>
* HTML : text/html
* plain ASCII : text/plain
* JPEG : image/jpeg
* GIF : image/gif

위처럼 각 멀티미디어 콘텐츠에 MIME 타입을 붙여 **웹-서버간** 객체를 주고 받게 됩니다.<br/>
<br/>

## URI
웹 서버 리소스는 각자의 이름을 가지고 있어 클라이언트는 관심있는 리소스를 지목할 수 있습니다.
**서버 리소스** 이름은 `통합 자원 식별자` 혹은 `URI`로 불립니다. URI는 우편주소와 같은 개념으로 고유하게 식별하고 위치를 지정할 수 있습니다.
예를들어 junjang의 블로그의 네트워크에 관련된 글에 대한 리소스의 URI 형식은 아래와 같습니다.
<br/>

> https://junjangsee.github.io/2019/07/29/network/network-01/

URI에는 두 가지가 있는데 `URL, URN`입니다. 이 두가지에 대해 살펴보겠습니다.<br/>
<br/>

### URL
URL(통합 자원 지시자)는 리소스 식별자의 가장 **흔한** 형태입니다. URL은 특정 서버의 리소스에 대한 구체적인 위치를 서술하고 있어 정확한 접근을 할 수 있도록 해줍니다.
여러가지 예시를 통해 URL의 구체적인 위치를 알아보겠습니다.
<br/>

> http://www.naver.com/index.html - naver홈페이지의 URL
> http://www.ROKA.com/datepick?date=190804 - 국방부 홈페이지에서 190804에 입영하는 URL

위 처럼 이런 표준 포멧을 따르고 있습니다.
- URL의 첫 부분은 **스킴(scheme)**인데, 여기선 리소스에 접근하기 위한 프로토콜을 서술합니다.(보통은 http://를 사용합니다.)
- 두 번째 부분은 **인터넷 주소**를 서술합니다.(www.naver.com)
- 마지막 부분은 **리소스**를 가르킵니다.(/hoguk/hoguki.gif)

<br/>

### URN
URN(유니폼 리소스 이름)은 하나의 리소스에 대해 그 리소스의 **위치에 영향을 받지 않는** `유일무이한 역할`을 합니다.
그래서 독립적인 URN은 어디로 옮기더라도 이상없이 동작합니다. 즉, `이름`만 동일하게 유지한다면 여러종류의 프로토콜로 접속해도 이상 없습니다.
URN은 현재 아직 실험 중인 상태이고 효율적으로 사용하기 위해선 인프라의 도움이 필요한데 그런 인프라의 부재로 현재 더뎌지고 있는 상태입니다.
때문에 현재로서는 URL과 URI를 같은 의미로서 사용할 것입니다.<br/>
<br/>

# 트랜잭션
`HTTP 트랜잭션`은 클라이언트와 웹 서버가 리소스를 주고받기 위해서 `요청명렁(클라이언트 -> 서버)`과 `응답 결과(서버 -> 클라이언트)`로 구성되어 있습니다. 이 상호작용이 어떻게 이루어지는지 알아보겠습니다.<br/>
<br/>

## 메소드
HTTP는 `HTTP 메소드`라고 불리는 여러가지의 요청 메소드를 지원합니다. 모든 HTTP 요청 메시지는 하나의 HTTP 메소드를 가집니다. 이 메소드는 서버가 어떤 동작을 취해야하는지 알려주는 역할을 합니다.(군대에서 일과시작 전 일과분류 받는 느낌입니다... 메소드 - 소대장, 서버 - 용사들)
가장 흔히 사용되는 5가지의 종류를 살펴보겠습니다.<br/>

* GET : 서버에서 클라이언트로 지정한 리소스를 보냅니다.
* PUT : 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장합니다.
* DELETE : 지정한 리소스를 서버에서 삭제합니다.
* POST : 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보냅니다.
* HEAD : 지정한 리소스에 대한 응답에서, HTTP 헤더 부분만 보냅니다.

<br/>

## 상태 코드
HTTP의 응답에 대해서는 무조건 `상태 코드`를 함께 반환하게 되어있습니다. 개발을 하다보면 흔히 보는 **200, 404** 등이 상태 코드에 해당됩니다.<br/>
<br/>

## 웹페이지는 여러 객체로 이루어질 수 있다.
애플리케이션은 하나의 작업을 수행하기 위해 여러 HTTP 트랜잭션을 수행합니다. 예를 들어, 하나의 웹페이지를 띄울 때 첨부된 이미지, HTML의 뼈대, 자바 애플릿 등을 가져오기 위해 추가로 HTTP 트랜잭션을 수행합니다. 이처럼 하나의 웹페이지는 **여러가지의 리소스**로 구성됩니다.<br/>
<br/>

# 메시지
HTTP 메시지는 두 종류로 이루어져 있습니다. 웹 클라이언트에서 서버로 보내는 `요청 메시지`, 서버에서 웹 클라이언트로 가는 `응답 메시지` 외에 HTTP 메시지는 없습니다.
이런 메시지에는 세 부분으로 이루어집니다.
* 시작줄 : 요청에서는 무엇을, 응답이라면 무슨 일이 일어났는지 나타냅니다.
* 헤더 : 0개 이상으로, 쌍점(:)으로 표현되며 **이름: 값** 으로 구성됩니다. 그리고 빈 줄로 끝납니다.
* 본문 : 요청의 본문은 웹 서버로 데이터를 **보내며**, 응답의 본문은 클라이언트로 데이터를 **반환**합니다.

<br/>

# TCP 커넥션
이제 TCP(전송 제어 프로토콜) 커넥션을 통해 한 곳에서 다른 곳으로 옮겨가지는 알아보겠습니다.<br/>
<br/>

## TCP/IP
HTTP는 애플리케이션 계층 프로토콜이며 네트워크의 세부적인 사항에 대해서는 일절 관여하지 않습니다. 대신 **대중성, 신뢰성** 두 가지를 담당하는 **인터넷 전송 프로토콜** `TCP/IP`에게 맡깁니다. TCP/IP는 아래의 3가지를 제공합니다.
* 오류 없는 데이터 전송
* 순서에 맞는 전달(보낸 순서대로 전달)
* 조각나지 않는 데이터 스트림

TCP/IP는 TCP, IP가 층을 이루는 패킷 교환 네트워크 프로토콜의 집합입니다. 각 하드웨어의 특성을 숨기고, 어떤 종류의 컴퓨터나 네트워크든 모두 신뢰성 있게 의사소통 하도록 해줍니다. HTTP는 메시지를 전송하기 위해 TCP를 사용합니다. 이와 비슷하게 TCP는 IP의 위의 계층입니다.<br/>

> HTTP > TCP > IP

<br/>

## 접속, IP 주소, 포트 번호
먼저 HTTP 클라이언트가 서버에 메시지를 전송할 수 있도록 **인터넷 프로토콜(IP) 주소**와 **포트번호**를 사용해 클라이언트와 서버 사이에 TCP/IP 커넥션을 맺어주어야 합니다.
TCP는 포트번호를 필요로 합니다. 
그런데 이런 정보를 도대체 어디서 가져와야 할까요? 일일이 알아내서 입력해주어야 할까요? 🤔<br/>

바로 URL에서 가져올 수 있습니다. 바로 예시를 보겠습니다.
* http://207.200.83.29:80/index.html : IP와 포트번호를 가진 경우
* http://www.netscape.com:80/index.html : 호스트명(도메인)과 포트번호를 가진 경우
* http://www.netscape.com/index.html : 둘 다 없는 경우 - 기본 포트번호는 80으로 세팅됩니다.

이런 URL을 가지고 TCP/IP 커넥션을 하여 쉽게 통신할 수 있습니다. 그렇다면 클라이언트와 서버간의 통신을 어떤 **순서**를 통해 하는지 살펴보겠습니다.

1. 웹브라우저는 서버의 URL에서 호스트명을 추출합니다.
2. 웹브라우저는 서버의 호스트명을 IP로 변환합니다.
3. 웹브라우저는 URL에서 포트번호를 추출합니다.
4. 웹브라우저는 웹 서버와 TCP 커넥션을 맺습니다.
5. 웹브라우저는 서버에 HTTP 요청을 보냅니다.
6. 서버는 웹 브라우저에 HTTP 응답을 반환홥니다.
7. 커넥션이 닫히면, 웹브라우저는 문서를 보여줍니다.

위와 같이 일련의 순서를 통해 HTML 리소스를 최종적으로 보여줍니다.<br/>
<br/>

# 프로토콜 버전
오늘날 사용하는 HTTP 프로토콜의 버전에는 여러가지가 있습니다. 하나하나 살펴보겠습니다.
* HTTP/0.9 : 심각한 디자인 결함으로 GET 메소드만 지원했으며 MIME 타입, HTTP 헤더, 버전 번호를 지원하지 않았고 금방 1.0으로 대체되었습니다.
* HTTP/1.0 : 널리 사용하기 시작한 버전으로 HTTP 헤더, MIME 타입, 추가 메소드, MIME 타입을 추가했습니다.
* HTTP/1.0+ : 1990년 인터넷이 급성장 하면서 'Keep-alive' 커넥션, 가상 호스팅, 프록시 연결 등 많은 기능을 추가하였습니다.
* HTTP/1.1 : HTTP 설계의 구조적 결함 교정, 성능 최적화, 잘못된 기능 제거를 하였고 더 복잡한 웹 애플리케이션과 배포를 지원합니다. 현재의 HTTP 버전입니다.
* HTTP/2.0 : 1.1의 성능 문제를 개선하기 위해 구글의 SPDY 프로토콜을 기반으로 설계가 진행중인 프로토콜입니다.

<br/>

# 웹의 구성요소
이 주제에서는 프록시, 캐시, 게이트웨이, 터널, 에이전트에 대해 살펴보겠습니다.<br/>
<br/>

## 프록시
`웹 보안, 애플리케이션 통합, 성능 최적화`의 중요한 역할을 수행합니다.
서버와 서버 **사이**에 위치하며 클라이언트의 모든 HTTP 요청을 받아 서버에 전달합니다. 이는 사용자를 대신해서 서버에 접근하는 의미로 주로 **보안**을 위해 사용됩니다.
즉, 모든 웹 트래픽 흐름 속에서 신뢰할 만한 **중개자** 역할을 합니다. 또한 `필터링` 역할을 수행하며 원하는 리소스만 받아낼 수도 있습니다.<br/>
<br/>

## 캐시
캐시는 자신을 거쳐 가는 문서들 중 자주 찾는 것의 사본을 저장해둡니다. 그래서 클라이언트가 해당 문서를 요청하면 그 캐시가 가지고 있는 문서를 가져올 수 있습니다.
캐시에 저장해둔 문서는 클라이언트와 가깝게 위치하고 있어 멀리 떨어진 웹 서버보다 훨씬 빠르게 문서를 전달할 수 있습니다.<br/>
<br/>

## 게이트웨이
다른 서버를 중개하는 역할을 하는 특별한 서버로 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용됩니다. 자기 자신이 언제나 리소스를 가지고 있는 진짜 서버인 것처럼 요청을 다룹니다.
그래서 클라이언트는 자신이 게이트웨이와 통신하고 있음을 알아채지 못하게 됩니다.<br/>
<br/>

## 터널
터널은 두 커넥션 사이에서 날(raw) 데이터를 열어보지 않고 그대로 전달해주는 HTTP 애플리케이션입니다. HTTP 터널은 주로 비 HTTP 데이터를 하나 이상의 HTTP 연결을 통해 그대로 전송해주기 위해 사용됩니다.
대표적으로 **암호화된 SSL 트래픽**을 **HTTP 커넥션으로 전송함**으로써 웹 트래픽만 허용하는 사내 방화벽을 통과시키는 것이 있습니다.<br/>
<br/>

## 에이전트
에이전트는 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램입니다.<br/>
<br/>