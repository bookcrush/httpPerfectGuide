# HTTP 

## 7.7 캐시 처리 단계

HTTP GET 메시지 하나를 처리하는 기본적인 캐시 처리 절차는 7 단계로 나누어져 있다.

### 7.7.1. 요청 받기 - 네트워크로 부터 도착한 요청 메시지를 받는다.

데이터를 읽어들인다. 고성능 캐시는 여러 개의 들어오는 커넥션들로부터 데이터를 동시에 읽어들이고 전체가 도착하기 전에 트랜잭션 처리를 한다.

### 7.7.2. 파싱 - 메시지를 파싱하여 URL 과 헤더들을 추출한다.

메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료구조에 담는다.

### 7.7.3. 검색 - 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아온다.

URL 을 알아내고 그에 해당하는 로컬 사본이 있는지 검사한다. 
만약 문서를 가져올 수 없다면 상황이나 설정에 따라서 원 서버나 부모 프락시에서 가져오거나 혹은 실패를 반환단다.

### 7.7.4. 신선도 검사 - 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어본다.

HTTP 는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해준다.
이 기간동안은 문서는 신선한 것으로 간주되고 캐시는 서버와의 접촉 없이 문서를 제공할 수 있다.
'신선하지 않은 경우' 에는 어떤 변경이 있었는지 검사하기 위해 서버와 재검사를 해야한다.

### 7.7.5. 응답 생성 - 응답 메시지를 만든다

캐시된 응답을 원 서버에서 온 것처럼 보이게 하기 위해 서버 응답 헤더를 토대로 응답 헤더를 생성한다.
캐시가 Date 헤더를 조정해서는 안된다.

### 7.7.6. 발송 - 응답을 클라이언트에게 돌려준다.

헤더가 준비되면 클라이언트에게 돌려준다. 프락시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있다.
코성능 캐시는 종종 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서의 콘텐츠 복사를 피함으로써 데이터를 효과적으로 전송하기 위해 노력한다

### 7.7.7 로깅 - 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다.

트랜잭션이 완료된 후 캐시는 통계 캐시 적중과 부적중 횟수에 대한 통계를 갱신하고 로그 파일에 요청 종류, URL 그리고 무엇이 일어났는지를 알려주는 항목을 추가한다.

## 7.8 사본을 신선하게 유지하기

캐시된 사본 모두가 서버의 문서와 항상 일치하는 것은 아니다. HTTP 는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와
충분히 일치하도록 유지할 수 있게 해주는 단순한 메커니즘을 갖고 있다. 이를 문서만료와 서버 재검사라고 부른다.

### 7.8.1 문서 만료

HTTP 는 Cache-Control 과 Expires 라는 헤더를 이용하여 원 서버가 문서에 유효기간을 붙일 수 있게 해준다.
캐시된 문서가 만료되면 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사해야한다.

### 7.8.2 유효기간과 나이 

서버는 응답 본문과 함께 하는, HTTP/1.0+ Expires 나 HTTP/1.1 Cache-Control:max-age 응답 헤더를 이용해서 유효기간을 명시한다.

- Cache-Control:max-age: 문서의 최대 나이를 정의한다. 문서가 처음 생성된 이후부터 계산
- Expires: 절대 유효기간을 정의 

### 7.8.3 서버 재검사

문서가 만료되었다는 것은, 원 서버에 현재 존재하는것과 다르다는 것을 의미하지는 않는다. 검사할 시간이 되었음을 뜻한다.

- 검사결과 변경되었다면 새로운 사본을 가져와 저장하고 클라이언트에게 보내준다.
- 변경되지 않았따면 새 만료인을 포함한 새 헤더들만 가져와 갱신한다.

### 7.8.4 조건부 메서드와의 재검사

HTTP의 조건부 메서드는 재검사를 효율적으로 만들어준다. 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 하는 것이다.
HTTP는 다섯 가지 조건부 요청 헤더를 정의한다. 'if' 라는 접두어로 시작한다.

- if-modified-since: 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리한다. 
- if-none-match: 마지막 변경된 날짜를 맞춰보는 대신, 문서에 대한 일련번호와 같이 동작하는 특별한 태그를 제공할 수 있다. 태그가 서버에 있는 문서의 태그와 다를 때만 수행한다.

### if-modified-since: 날짜 재검사

IMS 요청으로 줄여부른다. IMS 요청은 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고한다.

- 만약 문서가 주어진 날짜 이후에 변경되었다면, IMS 는 참이고 새 문서가 새로운 만료 날짜와 헤더들과 함께 제공된다.
- 문서가 주어진 날짜 이후에 변경되지 않았다면 조건은 거짓이고, 서버는 작은 304 Not Modififed 응답 메시지를 클라이언트에게 돌려준다.

### if-none-match: 엔터티 태그 재검사

최근 변경 일시 재검사가 행해지기 어려운 상황이 몇가지 있다.

- 내용에는 아무런 변화가 없더라도 변경시각은 바뀔 수 있다.
- 전 세계의 캐시들이 데이터를 다시 읽어들이기엔 사소한 것일 수도 있다.
- 어떤 서버들은 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별할 수 없다.
- 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버들에게는, 변경일에 대한 1초의 정밀도는 충분하지 않을 수 있다.

캐시가 객체에 대한 여러 개의 사본을 갖고 있는 경우, 그 사실을 서버에게 알리기 위해 하나의 if-none-match 헤더에 여러 개의 엔터티 태그를 포함 할 수 있다.

```text
If-None-Match: "v2.6"
If-None-Match: "v2.4", "v2.5", "v2.6"
If-None-Match: "foobar", "A34FAC0065", "Profiles in Courage"
```

### 7.8.7 약한 검사기와 강한 검사기 

서버가 갖고 있는 캐시에 대해 최신인지 확인하기 위해 엔터티 태그를 사용한다. 태그와 최근 변경일시는 둘 다 캐시 검사기다.
HTTP/1.1 은 비록 콘텐츠가 조금 변경되었더라도 "그 정도면 같은것" 이라고 서버가 주장할 수 있도록 해주는 약한 검사기를 지원한다.
강한 검사기는 콘텐츠가 바뀔때마다 바뀐다.

원서버는 서로 다른 두 엔터티에 대해 강한 엔터티 태그 값을 재활용해서는 안되며, 약한 엔터티 태그 값이라고 할지라도 서로 의미가 다른 두 엔터티에 대해서는 재활용해서는 안된다는 것에 주의해라.

### 7.8.8 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

HTTP/1.1 클라이언트는 만약 서버가 엔터티 태그를 반환했다면, 엔터티 태그 검사기를 사용해야 한다.
서버가 Last-Modified 값만을 반환했다면, 클라이언트는 If-Modified-Since 검사를 사용할 수 있다.

HTTP/1.1 원 서버는 가능하다면 엔터티 태그 검사기를 보내야 하며, 이점이 있다면 강한 엔터티 태그 대신 약한 엔터티 태그를 보낼 수도 있다. (Last-Modified 값을 보내는 것도 선호)
HTTP/1.1 캐시나 서버가 IMS 와 엔터티 태그 조건부 헤더를 모두 받았다면 304 를 반환해서는 안된다.

## 7.9 캐시 제어 

HTTP 는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러가지 방법을 정의한다.

- Cache-Control: no-store, no-cache, must-revalidate, max-age 헤더를 응답에 첨부 할 수 있다.
- Expires: 날짜 헤더를 응답에 첨부할 수 있다.

### 7.9.1 no-cache, store 응답 헤더 

HTTP/1.1 은 신선도를 관리하기 위해, 객체를 캐시하는 것을 제한하거나 캐시된 객체를 제공하는 여러가지 방법을 제공한다.
no-cache, store 헤더는 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막는다.

'no-cache' 가 표시된 응답은 응답의 사본을 만드는 것을 금지한다. 로컬 저장소에는 저장이 가능하나 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없을 뿐이다.

### 7.9.2 Max-Age 응답 헤더 

Cache-Control: max-age 헤더는 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간이고, 초로 나타낸다. 
서버는 최대 나이먹음을 0 으로 설정함으로써, 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있다.

### 7.9.3 Expires 응답 헤더

초 단위의 시간 대신 실제 만료 날짜를 명시한다.
몇몇 서버는 항상 만료되도록 하기 위해 Expires:0 응답 헤더를 돌려보내지만, 이는 문법 위반이다.

### 7.9.4 Must-Revalidate 응답 헤더 

성능을 개선하기 위해 신선하지 않은 객체를 제공하도록 설정될 수 있다. 
응답헤더는 캐시가 객체의 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공할 수 없음을 의미한다.
신선도 검사를 시도했을 때 원 서버가 사용할 수 없는 상태라면, 캐시는 반드시 504 Gateway Timeout error 를 반환해야한다.

### 7.9.5 휴리스틱 만료 

max-age, expires 헤더 중 어느 것도 포함하지 않고 있다면, 캐시는 경험적인 방법으로 최대 나이를 계산할 것 이다.

- LX 인자 알고리즘: 문서가 최근 변경 일시를 포함하고 있다면 사용 할 수 있다. 문서가 얼마나 자주 바뀌는지에 대한 추정에 사용한다.

캐시는 일반적으로 신선도에 대한 아무런 단서가 없는 문서에 대해 기본 신선도 유지기간을 설정한다. (보통 한시간, 하루)  캐시가 클라이언트에게 데이터를 제공할 때마다 신선한지 검사하도록 강제한다.

### 7.9.6 클라이언트 신선도 제약

웹 브라우저는 브라우저나 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시켜주는 리프레시나 리로드 버튼을 갖고 있다.
클라이언트는 문서를 최신으로 유지할 필요가 있는 애플리케이션을 더 엄격하게 할 수 있다. 

- max-stale: 신선하지 않은 문서라도 자유롭게 제공할 수 있다.
- min-fresh: 신선한 문서만을 받아들인다.
- max-age: s 초보다 오랫동안 캐시된 문서를 반환할 수 없다.
- no-cache: 재검사하기 전에는 받아들여지지 않는다.
- no-store: 저장소에서 문서의 흔적을 최대한 빨리 삭제해야한다. 문서에는 민감한 정보가 포함되어있기 때문이다.
- only-if-cached: 캐시에 들어있는 사본만 원한다.

## 7.10 캐시 제어 설정 

### 7.10.1 아파치로 HTTP 헤더 제어하기

- mod_headers:  개별 헤더들을 설정할 수 있게 해준다. 개별 HTTP 헤더를 제어할 수 있는 지시어를 이용해 아파치 설정 파일에 설정을 추가할 수 있다. 헤더들을 연결시키기 위해 아파치의 정규 식과 필터를 조합하여 사용할 수 있다.

```text
<Files *.html>
  Header set Cache-control no-cache
</Files>
```

- mod_expires: 만료 날짜가 담긴 expires 헤더를 자동으로 생성하는 프로그램 로직을 제공한다. 
- mod_cern_meta: HTTP 헤더들의 파일을 특정 객체와 연결시켜준다.

### 7.10.2 HTTP-EQUIV 를 통한 HTML 캐시 제어 

HTTP 서버 응답 헤더는 문서의 만료와 캐시 제어 정보를 돌려주기 위해 사용된다. 웹 서버는 제공할 문서에 올바른 캐시 제어 헤더들을 부여하기 위해 설정 파일들과 상호작용한다.
상호작용 없이 쉽게 HTTP 헤더를 부여할 수 있도록 하기위해 <META HTTP-EQUIV> 태그를 정의했다.
  
```html
<META HTTP-EQUIV="Cache-control" CONTENT="no-cache">
```

이 기능을 지원하는 웹 서버나 프락시는 거의 없다. 서버의 부하를 가중시키고, 설정값이 정적이고, HTML 을 제외한 다른 타입의 파일은 지원하지 않기 때문이다.



