# HTTP

## 6.6 메시지 추적

프락시가 점점 흔해지면서, 서로 다른 스위치와 라우터를 넘나드는 IP 패킷의 흐름을 추적하는 것 못지 않게 프락시를 넘나드는 메시지의 흐름을 추적하고 문제점을 찾아내는 것도 필요한 일이 되었다.

### 6.6.1 Via 헤더 

Via 헤더 필드는 메시지가 지나는 가 중간 노드의 정보를 나열한다.
메시지의 전달을 추적하고, 메시지 루프를 진단하고, 요청을 보내고 그에 대한 응답을 돌려주는 과정에 관여하는 모든 메시지 발송자들의 프로토콜을 다루는 능력을 알아보기 위해 사용된다.

Via 문법

```text
Via = "Via":" { waypoint } [", "{ waypoin } ...]
waypoint = ( received-protocol received-by [ comment ] )
received-protocol = [ protocol-name "/" ] protocol-version 
receved-by = ( host [ ":" prot ] ) | pseudnym
```

- 프로토콜 이름: 프로토콜이 만약 HTTP 라면 프로토콜 이름은 없어도 된다. 프로토콜 이름은 버전 앞에 "/" 로 구분되어 붙는다. 
- 프로토콜 버전: 버전의 포맷은 프로토콜에 달려있다. 버전은 via 필드에 포함되므로, 애플리케이션들은 자신 이전의 모든 중개자들이 어떤 버전을 다룰 수 있는지 알 수 있다.
- 노드 이름: 정보 보호를 이유로 진짜 호스트 명을 밝히고 싶지 않을때 가명으로 대체 할 수 있다.
- 노드 코멘트: 중개자 노드를 서술하는 선택적인 코멘트, 벤더나 버전 정보를 포함
- Via 요청과 응답 경로: 요청 메시지와 응답 메시지 모두 프락시를 지나므로 둘 모두 Via 헤더를 가진다. 응답의 Via 헤더는 언제나 요청 Via 헤더의 반대다
- Via 게이트웨이: 서버에게 비 HTTP 프로토콜을 사용할 수 있는 게이트웨이 기능을 제공한다. 선택적 코멘트는 프락시 서버의 브랜드, 버전 번호, 몇 가지 벤더 진단 정보를 포함한다.
- Server 헤더와 Via 헤더: Server 응답 헤더 필드는 원 서버에 의해 사용되는 소프트웨어를 알려준다. 
- Via 가 개인정보 보호와 보안에 미치는 영향: 호스트 명이 노출되기 원치 않는다면 호스트명을 가명으로 교체해야한다. 프락시는 정렬된 일련의 via 유지 항목들을 하나로 합칠 수 있다. 경유지들이 모두 같은 조직의 통제하에 있고 호스트가 이미 가명으로 교체되지 않은 이상 그들에 대한 항목들을 합쳐서는 안된다. 프로토콜 값이 서로 다른 항목들도 합쳐서는 안된다.

## 6.6.2 TRACE 메서드

프락시 서버는 메시지가 전달될 때 멤시지를 바꿀 수 있다. 헤더가 추가되거나, 변경되거나, 삭제될 수 있으며, 본무니 다른 형식으로 변환될 수 있다.
HTTP/1.1 의 TRACE 메서드는 요청 메시지를 프락시의 연쇄를 따라가면서 어떤 프락시를 지나가고 프락시가 요청 멤시지를 수정하는지 관찰/추적할 수 있게 해준다.

- Max-Forwards: TRACE 와 OPTIONS 요청의 프락시 홉 개수를 제한하기 위해 Max-Forwards 헤더를 사용할 수 있는데, 이는 전달되는 메시지가 무한 루프에 빠지지 않는지 프락시 연쇄를 테스트하거나 연쇄 중간의 특정 프락시 서버들의 효과를 체크할 때 유용하다.

## 6.7 프락시 인증 

HTTP 는 사용자가 유요한 접근 권한 자격을 프락시에 제출하지 않는 한 콘텐츠에 대한 요청을 차단하는 프락시 인증이라는 매커니즘을 정의하고 있다.

## 6.8 프락시 상호운용성 

서로 다른 프로토콜을 구현했을 수도 있고 이상한 동작을 할 수도 있는 클라이언트와 서버 사이를 중개해야 한다.

### 6.8.1 지원하지 않는 헤더와 메서드 다루기

프락시는 이해할 수 없는 헤더 필드는 반드시 그대로 전달해야 하며, 같은 이름의 헤더 필드가 여러 개 있는 경우에는 그들의 상대적인 순서도 반드시 유지해야 한다.
만약 프락시가 어떤 메서드와 친숙하지 않다면, 가능한 한 그 메시지를 다음 홉으로 전달하려 시도해야한다.

### 6.8.2 OPTIONS: 어떤 기능을 지원하는지 알아보기 

HTTP OPTIONS 메서드는 서버나 웹 서버의 특정 리소스가 어떤 기능을 지원하는지 클라이언트가 알아볼 수 있게 해준다.

### 6.8.3 Allow 헤더 

Allow 엔터티 헤더 필드는, 요청 URI 에 의해 식별되는 자원에 대해 지원되는 메서드들이나 서버가 지원하는 모든 메서드를 열거한다. 
Allow 헤더는 새 리소스가 지원했으면 하는 메서드를 추천하기 위해 요청 헤더로 사용될 수 있다.

## 캐시 

웹 캐시는 문서의 사본을 자동으로 보관하는 HTTP 장치이다 
요청이 캐시에 도착했을 때 로컬 사본이 존재한다면 문서는 원 서버가 아니라 캐시로부터 제공된다.

- 캐시는 네트워크의 병목을 줄여준다.
- 불필요한 데이터 전송을 줄여준다.
- 원 서버에 대한 요청을 줄여준다.
- 거리로 인한 지연을 줄여준다.

## 7.1 불필요한 데이터 전송 

똑같은 바이트들이 네트워크를 통해 계속 반복적으로 이동할때 불필요한 데이터 전송이 일어난다.
데이터 전송은 값비싼 네트워크 대역폭을 잡아먹고, 전송을 느리게 만들며, 웹 서버에 부하를 준다.
캐시를 이용하면, 첫 번째 응답은 캐시에 보관된다.

## 7.2 대역폭 병목 

캐시는 또한 네트워크 병목을 줄여준다. 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다.
클라이언트들이 서버에 접근할때의 속도는 경로에 있는 가장 느린 네트워크의 속도와 같다. 
캐싱을 이용한다면 성능을 대폭 개선할 수 있을 것이다.

## 7.3 갑작스런 요청 쇄도 

캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요하다. 
불필요한 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 야기시킨다. 

## 7.4 거리로 인한 지연 

대역포이 문제가 되지 않더라도 거리가 문제가 될 수 있다.
모든 네트워크 라우터는 인터넷 트래픽을 지연시킨다. 빛의 속도 그 자체가 유의미한 지연을 유발한다.

## 7.5 적중과 부적중 

캐시가 세상 모든 문서의 사본을 저장하지는 않는다.
캐시에 요청이 도착했을 떄 그에 대응하는 사본이 있다면 그를 이용해 요청이 처리될 수 있다.
이를 캐시 적중이라고 부른다. 사본이 없다면 원 서버로 전달되기만 할 뿐이다. 이를 캐시 부적중 이라고 부른다.

### 7.5.1 재검사 

원 서버 컨텐츠를 변경 될 수 있기 때문에, 캐시는 반드시 사본이 최신인지 점검이 필요하다.
재검사가 필요할때 원 서버에 작은 재검사 요청을 보낸다. 콘텐츠가 변경되지 않았다면 서버는 304 Not Modified 응답을 보낸다.

- 재검사 적중: 만약 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 작은 HTTP 304 Not Modified 응답을 보낸다.
- 재검사 부적중: 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 응답을 클라이언트에게 보낸다.
- 객체삭제: 서버 객체가 삭제되었다면, 서버는 404 Not Found 응답을 돌려보내며 사본을 삭제한다.

### 7.5.2 적중률

캐시가 요청을 처리하는 비율을 캐시 적중률 혹은 문서 적중률이라고 부른다.

### 7.5.3 바이트 적중률

문서들이 모두 같은 크기인 것은 아니기 때문에 문서 적중률이 모든 것을 말해주지 않는다.
어떤 사람들은 바이트 단위 적중률 측정값을 더 선호한다
바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다.
이 측정값은 트래픽이 절감된 정도를 포착한다.

### 7.5.4 적중과 부적중의 구별 

HTTP 는 클라이언트에게 응답이 캐시 적중이었는지 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다.
두 경우 모두 응답이 200 으로 내려간다. 클라이언트 응답이 캐시 헤더에서 왔는지 알아내는 한 가지 방법은 Date 헤더를 이용하는 것이다.
응답의 Date 헤더 값을 현재 시각과 비교하여, 응답의 생성일이 더 오래 되었다면 캐시된 것임을 알아낼 수 있다.

## 7.6 캐시 토폴로지 

한 명에게만 할당된 캐시를 개인 전용 캐시라 부른다. 공유된 캐시는 공용 캐시라고 부른다.

### 7.6.1 개인 전용 캐시 

개인 전용 캐시는 많은 에너지나 저장 공간을 필요로 하지 않으므로 작고 저렴할 수 있다. 브라우저는 개인 전용 캐시를 내장하고 있다.
브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용한다.

### 7.6.2 공용 프락시 캐시 

공용 프락시 캐시는 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버다.
개인 전용 캐시는 같은 문서를 네트워크를 거쳐 여러번 가져온다. 
공유된 공용 캐시는 자주 찾는 객체를 단 한번만 가져와 모든 요청에 대해 공유된 사본을 제공하므로써 네트워크 트래픽을 줄인다.

### 7.6.3 프락시 캐시 계층들 

작은 캐시에서 캐시 부적중이 발생했을 때 부모 캐시가 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적인 경우가 많다.
캐시 계층이 깊다면 요청은 캐시의 긴 연쇄를 따라가게 될 것이다. 트락시 연쇄가 길어질수록 중간 프락시는 현저한 성능 저하가 발생할 것 이다.

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링 

캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여, 어떤 부모 캐시와 대화할 것인지 아니면 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에 대한 커뮤니케이션을 동적으로 결정한다.

선택적인 피어링을 지원하는 캐시는 형제 캐시라고 불린다. HTTP 는 형제 캐시를 지원하지 않기 때문에 인터넷캐시 프로토콜(ICP)나 하이퍼텍스트 캐시 프로토콜같은 것들을 이용해 HTTP 를 확장했다. 

