# HTTP 완벽가이드

## 클라이언트 식별과 쿠키

### 11.1 개별 접촉

HTTP 는 익명으로 사용하며 상태가 없고 요청과 응답으로 통신하는 프로토콜이다.
웹 서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.

- 개별 인사: 온라인 쇼핑이 개인에게 맞춰져 있는 것처럼 느끼게 하려고 사용자에게 특화된 환영 메시지나 페이지 내용을 만든다.
- 사용자 맞춤 추천: 고객의 흥미를 학습하여 좋아할 것으로 예상되는 제품을 추천할 수 있다.
- 저장된 사용자 정보: 쇼핑을 편하게 할 수 있게 저장된 사용자 정보를 사용할 수 있다.
- 세션 추적: 위와 같은 사이트와의 상호작용을 위해서는 사용자에게서 오는 HTTP 트랜잭션을 식별할 방법이 필요하다. 
  - 사용자 식별 관련 정보를 전달하는 HTTP 헤더
  - IP 주소로 사용자를 식별
  - 사용자 로그인 인증을 통한 사용자 식별
  - URL 에 식별자를 포함하는 기술인 뚱뚱한 URL
  - 식별 정보를 지속해서 유지하는 강력하면서도 효율적인 기술인 쿠키
  
 ### 11.2 HTTP 헤더
 
| Form            | 요청 | 사용자의 이메일 주소                     |
|-----------------|------|------------------------------------------|
| User-Agent      | 요청 | 사용자의 브라우저                        |
| Referer         | 요청 | 사용자가 현재 링크를 타고 온 근원 페이지 |
| Authorization   | 요청 | 사용자 이름과 비밀번호                   |
| Client-ip       | 확장 | 클라이언트의 IP 주소                     |
| X-Forwarded-For | 확장 | 클라이언트의 IP 주소                     |
| Cookie          | 확장 | 서버가 생성한 ID 라벨                    |

- Form 헤더에는 사용자 이메일 주소를 포함한다. 악용될 여지가 있어 Form 헤더를 보내는 브라우저는 많지 않다. 로봇이나 스파이더는 웹 사이트에 항의메일을 보낼 수 있도록 Form 헤더에 이메일 주소를 기술한다.
- User-Agent 헤더는 사용자가 쓰고있는 브라우저의 이름과 버전 정보, 운영체제에 대한 정보를 포함한다. 
- Referer 헤더는 유입하게 한 웹페이지의 URL 을 가리킨다. 사용자 자체 식별은 불가하지만 사용자의 취향을 파악하는데 도움을 준다.

### 11.3 클라이언트 IP 주소 

클라이언트 IP 주소로 사용자를 식별하는 방식은 다음과 같은 약점을 가지고있다.

- 클라이언트 IP는 사용자가 아닌, 사용자가 사용하는 컴퓨터를 가리킨다.
- 동적으로 IP 주소를 할당 받을 경우 사용자는 매번 새로운 IP 주소를 할당 받는다
- 보안을 강화하기 위해 많은 사용자가 네트워크 주소 변환 방화벽을 통해 인터넷을 사용한다
- HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결을 한다.

### 11.4 사용자 로그인

웹 서버는 사용자 이름과 비밀번호로 인증할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다.
웹 사이트 로그인이 더 쉽도록 HTTP 는 WWW-Authenticate 와 Authorization 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.

서버에서 접근전 로그인을 시키고자 한다면 401 Login Required 응답 코드를 브라우저에 보낼 수 있다.

### 11.5 뚱뚱한 URL

URL 은 URL 경로의 처음이나 끝에 어떤 상태 정보를 추가해 확장한다. 
뚱뚱한 URL 은 아래와 같은 문제점이 있다.

- 못생긴 URL: 뚱뚱한 URL 은 사용자에게 혼란을 준다.
- 공유하지 못하는 URL: 뚱뚱한 URL 은 사용자와 세션에 대한 상태 정보를 포함한다. 공유시 정보 노출에 위험이 있다.
- 캐시를 사용할 수 없음: URL이 달라지기 때문에 기존 캐시에 접근할 수 없다.
- 서버 부하 가중: 서버는 뚱뚱한 URL 에 해당하는 HTML 페이지를 다시 그려야 한다.
- 이탈: 의도치 않게 뚱뚱한 URL 세션에서 이탈했을때 이전 정보가 초기화된다.
- 세션 간 지속성의 부재: URL 을 북마킹 하지 않는이상 로그아웃하면 모든 정보를 잃는다.

## 11.6 쿠키 

쿠키는 사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식이다.
쿠키는 캐시와 충돌할 수 있어서 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않는다.

### 11.6.1 쿠키의 타입 

크게 세션쿠키 / 지속 쿠키 두 가지 타입으로 나눌 수 있다.
세션 쿠키는 사용자가 사이트를 탐샐할 때, 관련한 설정과 신호 사항들을 저장하는 임시 쿠키다. 브라우저를 닫으면 삭제된다.
지속 쿠키는 삭제되지 않고 더 길게 유지될 수 있다. 디스크에 저장되어 브라우저를 닫거나 재시작하더라도 남아있다.
Expires 혹은 Max-Age 가 없으면 세션쿠키가된다.

### 11.6.2 쿠키는 어떻게 동작하는가

쿠키는 이름=값 형태의 리스트를 가진다. 리스트는 Set-Cookie 혹은 Set-Cookie2 같은 HTTP 응답 헤더에 기술되어 사용자에게 전달된다.
브라우저는 서버로부터 온 쿠키 컨텐츠를 브라우저 쿠키 데이터베이스에 저장한다.

### 11.6.3 쿠키 상자: 클라이언트 측 상태 

쿠키의 기본적인 발상은 브라우저가 서버 관련 정보를 저장하고, 사용자가 해당 서버에 접근할 떄마다 그 정보를 함께 전송하게 하는 것이다.
브라우저는 쿠키 정보를 저장할 책임이 있는데, 이 시스템을 클라이언트 측 상태라고한다. 쿠키 명세에서 이것의 공식적인 이름은 HTTP 상태 관리 체계이다.

#### 구글 크롬 쿠키: 구글 크롬은 Cookies 라는 SQLite 파일에 쿠키를 저장한다. 

- creation_utc: 쿠키가 생성된 시점
- host_key: 쿠키의 도메인
- name: 쿠키의 이름
- value: 쿠키의 값
- path: 쿠키와 관련된 도메인에 있는 경로
- expire_utc: 쿠키의 파기 시점 
- secure: 쿠키를 SSL 커넥션일 경우에만 보낼지 여부


### 11.6.4 사이트마다 각기 다른 쿠키들

브라우저는 쿠키를 모든 사이트에 보내지 않는다.

- 쿠키를 모두 전달하면 성능이 저하된다. 
- 서버에 특화된 이름을 가지고 있기 때문에 대부분의 사이트에서는 무의미한 값이다
- 잠재적인 개인정보 문제를 일으킬 수 있다.

보통 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다.

#### 쿠키 Domain 속성

서버는 쿠키를 생성할 때 Set-Cookie 응 답 헤더에 Domain 속성을 기술해서 어떤 사이트가 쿠키를 읽을 수 있는지 제어할 수 있다.

```text
Set-cookie: user="mary17"; domain="xxxxx.com"
```

#### 쿠키 Path 속성 

웹 사이트 일부에만 쿠키를 적용할 수도 있다. URL 경로의 앞부분을 가리키는 Path 속성을 기술해서 해당 경로에 속하는 페이지에만 쿠키를 전달한다.

```text
Set-cookie: pref=compact; domain="xxxxx.com"; path=/autos/
```

### 11.6. 쿠키 구성요소

현재 사용되는 쿠키 명세에는 Version 0 쿠키와 Version 1 쿠키가 있다. Version1 쿠키는 0 쿠키의 확장으로 널리 쓰이지는 않는다.

### 11.6.6 Version 0 넷스케이프 쿠키 

```text
Set-Cookie: name=value [; expires=date] [; path=path] [; domain=domain] [; secure] 
Cookie: name1=value1 [; name2=value2]
```

- 이름=값: Set-Cookie: customer=Mary
- Expires: 선택적인 속성, 쿠키의 생명주기를 가리키는 날짜 문자열을 기술
- Domain: 선택적인 속성, 이 속성에 기술된 도메인을 사용하는 서버 호스트 명으로만 쿠키를 전송한다.
- Path: 선택적인 속성, 서버에 있는 특정 문서에만 쿠키를 할당할 수 있다.
- Secure: 선택적인 속성, 쿠키는 HTTP 가 SSL 보안 연결을 사용할 때만 쿠키를 전송한다.

#### Version 0 Cookie 헤더

클라이언트가 서버에 요청을 보낼 때는 Domain, Path, Secure 필터들이 현재 요청하려고 하는 사이트에 들어 맞으면서 아직 파기되지 않은 쿠키들을 함께 보낸다. 모든 쿠키는 Cookie 헤더에 한데 이어 붙여 보낸다.

```text
Cookie: seesion-id=002-1145265; session-id-time=1007884800
```

### 11.6.7 Version1 RFC 2965 쿠키

RFC 2965 쿠키 표준은 워 버전인 넷스케이프 표준보다 좀 더 복잡하며, 모든 브라우저나 서버가 완전히 지원하지 않는다.
추가된 변경사항은 아래와 같다.

- 쿠키마다 목적을 설명하는 설명문이 있다.
- 파기 주기에 상관없이 강제 삭제가 가능하다
- 날짜 값 대신에 초 단위의 상대 값으로 쿠키의 생명주기를 결정할 수 있는 Max-age
- URL 의 포트번호로도 쿠키를 제어할 수 있다.
- 호환되는 버전 번호
- 도메인 포트 경로 필터가 있으면 Cookie 헤더에 담겨 되돌려 보낸다
- 키워드 구별을 위해 Cookie 헤더에 $ 접두어가 있다.

#### Version1 Set-Cookie2 헤더

Version1 쿠키 표준에는 넷스케이프 표준보다 더 많은 속성이 있다.

- 이름=값: 필수 속성, $는 예약 문자이므로 쿠키 이름은 $ 로 시작하면 안된다.
- Version: 쿠키 명세의 버전을 가리키는 정수 값
- Comment: 선택적인 속성, 서버가 쿠키를 사용하려는 의도를 기술한다.
- CommentURL: 선택적인 속성, 쿠키를 사용하는 목적과 정책에 대해 상세히 기술된 웹 페이지 링크를 제공한다.
- Discard: 선택적인 속성, 클라이언트 프로그램이 종료될 때 클라이언트가 해당 쿠키를 삭제한다.
- Domain: 선택적인 속성, 기술된 도메인에 해당하는 서버 호스트들에게만 쿠키를 전송한다.
- Max-Age: 선택적인 속성, 쿠키의 생명주기를 초 단위로 산정한 정수 값
- Path: 선택적인 속성, 특정 문서에만 쿠키를 할당 할 수 있다.
- Port: 선택적인 속성, 값이 없이 속성으 ㅣ키워드만 기술할 수도 있고, 적용될 포트 한 개 이상을 콤마로 구분하여 기술할 수 있다.
- Secure: 선택적인 속성, HTTP가 SSL 보안 연결을 사용할 때만 쿠키가 전송된다.

#### Version1 Cookie 헤더 

Version1 Cookie 는 전송하려는 각 쿠키에 추가 정보를 담는데, 추가 정보에는 해당 쿠키가 가지고 있던 필터 중에서 현재의 사이트에 들어맞는 필터를 기술한다.
서버가 응답과 함께 전송했던 Set-Cookie2 헤더에 있는 Domain, Port, Path 같은 속성중에서, 들어맞는 필터를 함께 기술하여 쿠키를 전송해야한다.

#### Version 1 Cookie2 헤더와 버전 협상

Cookie2 요청 헤더는 각기 다른 쿠키 버전을 지원하는 클라이언트와 서버 간에 호환성을 협상하는 용도로 사용한다.
Cookie2 헤더는 사용자 에이전트가 새로운 형식의 쿠키를 지원하며, 해당 쿠키 표준의 버전 정보를 서버에 제공한다.

만약 클라이언트가 같은 쿠키를 Set-Cookie 와 Set-Cooki2 헤더에 기수랳서 모두 보내면 이전 방식인 Set-Cookie 헤더를 무시한다.

### 11.6.8 쿠키와 세션 추적

쿠키는 웹 사이트에 수차례 트랜잭션을 만들어내는 사용자를 추적하는데 사용한다.
전자상거래 웹 사이트는 사용자가 온라인 쇼핑을 하는 중에도 그들의 쇼핑카드를 유지하려 세션 쿠키를 사용한다.

### 11.6.9 쿠키와 캐싱

쿠키 트랜잭션과 고나련된 문서를 캐싱하는 것은 주의해야한다. 이전 사용자의 쿠키가 다른 사용자에게 할당돼버리거나, 누군가의 개인 정보가 다른 이에게 노출되는 최악의 상황이 일어날 수도 있다.

- 캐시되지 말아야 할 문서가 있다면 표시하라
- Set-Cookie 헤더를 캐시하는 것에 유의하라: 캐시가 요청마다 원 서버와 재검사시켜 클라이언트로 가는 응답에 set-cookie 헤더 값을 기술할 수 있다.
- Cookie 헤더를 가지고 있는 요청 주의하라: 요청이 Cookie 헤더와 함께 오면, 결과 컨텐츠가 개인정보를 담고 있을 수도 있다.

### 11.6.10 쿠키, 보안 그리고 개인정보

개인정보를 다루거나 사용자를 추적하는 기술은 잘못된 의도로 사용될 수 있기 때문에 항상 조심해야한다.
쿠키에 대한 부정적인 여론이 많기는 하지만, 제공하는 개인정보를 누가 받는지 명확히 알고 사이트의 개인정보 정책에만 유의한다면 쿠키에 관련한 위험성보다 세션 조작이나 트랜잭션상의 편리함이 더 크다 













