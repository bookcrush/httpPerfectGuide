# HTTP

## 19.2 WebDAV 와 공동 저작

웹 분산 저작과 버저닝은 웹 배포 공동 작업에 대한 또 다른 영역을 개척했다.
이메일을 사용하거나 분산 파일 공유를 함께 사용할 떄도 있다.
이 방식은 프로세스에 대한 제어를 거의 할 수 없어서 불편하고 에러가 많은 것으로 알려져있다.

### 19.2.1 WebDAV 메서드

- PROPFIND: 리소스의 속성을 읽는다.
- PROPPATCH: 한 개 이상의 리소스에 대해 한 개 이상의 속성을 설정한다.
- MKCOL: 콜렉션을 생성한다.
- COPY: 특정 원본지에서 특정 목적지로 리소스나 리소스의 집합을 복사한다. 목적지가 같은 기기에 있을 필요는 없다.
- MOVE: 특정 소스에서 특정 목적지에 리소스나 리소스의 집합을 이동시킨다. 목적지가 같은 기기에 있을 필요는 없다.
- LOCK: 하나 이상의 리소스를 잠근다
- UNLOCK: 기존에 잠겨있는 리소스를 잠금 해제한다.

### 19.2.2 WebDAV 와 XML

WebDAV 의 메서드는 요청과 응답 관련 정보를 모두 잘 다루어야 한다.
HTTP는 보통 이 정보를 메시지 헤더에 담아 전달한다.
하지만 헤더에만 정보를 담아 전송하는 것은, 하나의 요청에 있는 여러 개의 리소스나 계층 관계에 있는 리소스들에 대한 정보를
헤더에 선택적으로 기술하기 어려운 점 등의 한계가 있다.

WebDAV 는 이 문제를 해결하기 위해 XML 을 지원한다. 용도는 아래와 같다

- 데이터를 어떻게 처리 할지 명령 포맷
- 서버의 복잡한 응답을 표현하는데 사용
- 콜렉션 리소스를 처리하는데 사용
- 데이터 자체를 표현할 수 있는 포맷

WebDAV 는 "DAV:" 라는 별도의 XML namespace 를 정의한다. 

### 19.2.3 WebDAV 헤더 

- DAV: WebDAV 를 제공하는 서버와 통신할 떄 사용한다. WebDAV 에서 지원하는 모든 리소스는 OPTIONS 요청에 대한 응답에 이 헤더를 포함해야한다.
- Depth: 여러 수준의 계층 구조로 분류된 리소스에 WebDAV 를 사용하기 위한 중요한 요소다.
- Destination: COPY 나 MOVE 메서드가 목적지 URL 을 식별하는데 쓰인다.
- if: 정의되어 있는 상태 토큰은 lock 토큰뿐이다. if 헤더는 조건 집합을 정의한다. 조건이 맞지 않다면 해당 요청은 실패한다.
- lock-token: 제거되어야 할 잠금을 명시하는 용도로 UNLOCK 메서드에서 사용한다. LOCK 메서드에 대한 응답은 lock 토큰에 대한 필요한 정보를 전달하는 Lock-Token 헤더를 포함한다
- Overwrite: 대상을 덮어쓸 것인지 아닌지를 기술하는 데 쓰이며 COPY 나 MOVE 메서드에서 사용한다.
- Timeout: 클라이언트가 필요한 잠금 타임아웃 값을 기술하는 데 사용하는 요청 헤더다. 

### 19.2.4 WebDAV 잠금과 덮어쓰기 방지 

A 와 B 가 함께 작업할 때 서로의 작업물을 덮어씌울 수 있는 위험이 있다.
이 문제를 개선하기 위해 WebDAV 는 잠금 이라는 개념을 지원한다. 완벽한 해결책은 아니다.
완벽한 해결책을 만드려면 버저닝과 메시징을 지원해야 한다.

- 리소스나 콜렉션에 대한 배타적 쓰기 잠금
- 리소스나 콜렉션에 대한 공유된 쓰기 잠금 

배타적 쓰기 잠금은 잠금 소유자만 쓸 수 있게 보장한다. 이 잠금 혀식은 잠재적인 충돌을 완벽히 제거한다. 
공유된 쓰기 잠금은 여러 사람으로 이루어져 있는 그룹이 하나의 문서에서 작업 할 수 있게 한다.

잠금을 수행하려면, 저자를 식별하는 메커니즘을 필요한다. WebDAV는 다이제스트 인증을 요구한다.
잠금이 승인되면, 서버는 도메인 전체에서 유일한 토큰을 클라이언트에 반환한다.
명세에서는 이를 opaquelocktoken 잠금 토큰 URI 스킴이라고 부른다.
쓰기를 하려면 정확한 사용자와 잠금 토큰이 모두 결정되어야 한다.

### 19.2.5 LOCK 메서드 

WebDAV 의 강력한 기능은 한개의 LOCK 요청으로 여러 개의 리소스를 잠글 수 있다는 것이다.
WebDAV의 잠금은 클라이언트가 서버에 연결되어 있지 않아도 된다.

- <lockInfo>: 전송된 XML 에는 기본 요소로 lockInfo 를 가진다.
- <locktype>: 잠금 형식을 가리킨다. 현재는 단 한 개의 "write" 만 있다.
- <lockscope>: 배타적 잠금인지 공유된 잠금인지를 가리킨다.
- <owner>: 현재 잠금을 가지고 있는 사람이 기술되어 있는 필드다
- <locktoken>: URI 스킴에서 opaquelocktoken 이라 부르는 토큰으로 잠금을 식별하는데 사용한다.
- <depth> Depth 헤더와 같은 값을 가진다 
- <timeout>: 잠금에 대한 타임아웃을 가리킨다
- opaquelocktoken 스킴: 언제든 모든 리소스에 유일한 토큰을 제공하기 위해 설계되었다. 유일성을 보장하기 위해서 UUID 매커니즘을 사용한다
- <lockdiscovery> XML 요소: 활성화되어 있는 잠금을 찾는 매커니즘을 제공한다.
- 잠금 갱신과 Timeout 헤더: 잠금을 갱신하려면, 클라이언트는 If 헤더에 잠금 토큰과 함께 잠금 요청을 다시 보내야 한다.

### 19.2.6 UNLOCK 메서드

리소스에 있는 잠금을 제거한다.
리소스 관리 요청에서, WebDAV 에서 UNLOCK 를 성공하기 위한 두 가지 조건이 있다.
다이제스트 인증을 성공적으로 완료하는 것과 Lock-Token 헤더에 보내는 잠금 토큰이 맞는지 검사하는 것이 바로 그것이다.

[참고]:(https://docs.microsoft.com/en-us/previous-versions/office/developer/exchange-server-2003/aa143146(v%3Dexchg.65))

### 19.2.7 속성과 META 데이터 

속성에는 저작자의 이름, 수정 날짜, 내용 등급 등과 같은 리소스의 정보를 기술한다.
HTML 의 META 태그는 콘텐츠 일부로써 그 정보들을 포함하는 매커니즘을 제공한다. 

문서가 편집될 때, 새로운 저작자를 반영하여 갱신해야한다. WebDAV 용어로 그런 동적 수정 속성을 'live' 속성이라고한다.
거의 변하지 않는 Content-Type 과 같은 정적 속성을 'dead' 속성이라고한다.

속성의 발견과 수정을 지원하기 위해, WebDAV는 PROPFIND 와 PROPPATCH 라는 두 가지 새로운 메서드를 포함해 HTTP 를 확장한다 

### 19.2.8 PROPFIND 메서드 

주어진 파일이나 파일 그룹의 속성을 읽는 데 사용한다. 

- 모든 속성과 그 값을 요청한다.
- 선택된 속성과 그 값의 집합을 요청한다 
- 모든 속성의 이름을 요청한다

- <propfind>: PROPFIND 메서드로부터 반환될 속성들을 기술한다.
- <allprop>: 반환될 모든 속성의 이름과 값을 기술한다.
- <propname>: 반환될 속성 이름의 집합을 기술한다.
- <prop>: <propfind> 요소의 하위 요소다. 반환될 값의 속성을 기술한다.
- <multistatus>: 여러 응답을 담는 컨테이너
- <href> 리소스의 URI 를 가리킨다
- <status>: 특정 요청에 대한 HTTP 상태 코드를 기술한다
- <propstat>: <status> 요소 한 개와 <prop> 요소 한개로 이루어져 있는 집합이다. 

### 19.2.9 PROPPATCH 메서드 

특정 리소스의 여러 속성을 설정하거나 제거하는 원자적 매커니즘을 제공한다.
원자성은 모든 요청이 성공하거나 모든 요청이 무효화 되거나, 둘 중 하나만 수행하는 것을 보장한다.

- <propertyupdate>: PROPPATCH 의 기본 XML 요소
- <set>: 설정할 속성을 기술한다
- <remove>: 제거할 속성을 기술한다. 

[참고](https://docs.microsoft.com/en-us/previous-versions/office/developer/exchange-server-2003/aa142976(v%3Dexchg.65))

### 19.2.10 콜렉션과 이름공간 분리

콜렉션은 사전에 정의한 계층에 있는 리소스들의 논리적 혹은 물리적 그룹이다.
파일시스템의 디렉터리 같이 다른 리소스들의 컨테이너처럼 동작한다. 콜렉션은 다른 콜렉션을 포함한다.
WebDEV 는 XML namespace 메커니즘을 사용한다. 전통적인 namespace 와 달리 XML namespace 파티션들은 충돌이 절대 생기지 않게 하고
명확한 구조적 제어 기능을 제공한다. 

































